// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "catan/v1/types.proto" (package "catan.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// ==================== Core Types ====================

/**
 * Axial coordinates for hex grid
 *
 * @generated from protobuf message catan.v1.HexCoord
 */
export interface HexCoord {
    /**
     * @generated from protobuf field: int32 q = 1
     */
    q: number;
    /**
     * @generated from protobuf field: int32 r = 2
     */
    r: number;
}
/**
 * A hex tile on the board
 *
 * @generated from protobuf message catan.v1.Hex
 */
export interface Hex {
    /**
     * @generated from protobuf field: catan.v1.HexCoord coord = 1
     */
    coord?: HexCoord;
    /**
     * @generated from protobuf field: catan.v1.TileResource resource = 2
     */
    resource: TileResource;
    /**
     * @generated from protobuf field: int32 number = 3
     */
    number: number; // 2-12, 0 for desert
}
/**
 * A settlement or city
 *
 * @generated from protobuf message catan.v1.Building
 */
export interface Building {
    /**
     * @generated from protobuf field: catan.v1.BuildingType type = 1
     */
    type: BuildingType;
    /**
     * @generated from protobuf field: string owner_id = 2
     */
    ownerId: string;
}
/**
 * A road segment
 *
 * @generated from protobuf message catan.v1.Road
 */
export interface Road {
    /**
     * @generated from protobuf field: string owner_id = 1
     */
    ownerId: string;
}
/**
 * A corner where buildings can be placed
 *
 * @generated from protobuf message catan.v1.Vertex
 */
export interface Vertex {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: repeated catan.v1.HexCoord adjacent_hexes = 2
     */
    adjacentHexes: HexCoord[];
    /**
     * @generated from protobuf field: optional catan.v1.Building building = 3
     */
    building?: Building;
}
/**
 * A side where roads can be placed
 *
 * @generated from protobuf message catan.v1.Edge
 */
export interface Edge {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: repeated string vertices = 2
     */
    vertices: string[]; // Always 2 vertex IDs
    /**
     * @generated from protobuf field: optional catan.v1.Road road = 3
     */
    road?: Road;
}
/**
 * Count of each resource
 *
 * @generated from protobuf message catan.v1.ResourceCount
 */
export interface ResourceCount {
    /**
     * @generated from protobuf field: int32 wood = 1
     */
    wood: number;
    /**
     * @generated from protobuf field: int32 brick = 2
     */
    brick: number;
    /**
     * @generated from protobuf field: int32 sheep = 3
     */
    sheep: number;
    /**
     * @generated from protobuf field: int32 wheat = 4
     */
    wheat: number;
    /**
     * @generated from protobuf field: int32 ore = 5
     */
    ore: number;
}
/**
 * A player's current state
 *
 * @generated from protobuf message catan.v1.PlayerState
 */
export interface PlayerState {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: catan.v1.PlayerColor color = 3
     */
    color: PlayerColor;
    /**
     * @generated from protobuf field: catan.v1.ResourceCount resources = 4
     */
    resources?: ResourceCount;
    /**
     * @generated from protobuf field: int32 dev_card_count = 5
     */
    devCardCount: number; // Hidden from other players
    /**
     * @generated from protobuf field: int32 knights_played = 6
     */
    knightsPlayed: number;
    /**
     * @generated from protobuf field: int32 victory_points = 7
     */
    victoryPoints: number;
    /**
     * @generated from protobuf field: bool connected = 8
     */
    connected: boolean;
    /**
     * @generated from protobuf field: bool is_ready = 9
     */
    isReady: boolean; // Ready to start the game (lobby only)
    /**
     * @generated from protobuf field: bool is_host = 10
     */
    isHost: boolean; // Host can start game when all ready
    /**
     * @generated from protobuf field: int32 victory_point_cards = 11
     */
    victoryPointCards: number; // Number of VP dev cards in hand (hidden from other players)
    /**
     * @generated from protobuf field: map<int32, int32> dev_cards = 12
     */
    devCards: {
        [key: number]: number;
    }; // Map of DevCardType enum value -> count (hidden from other players)
    /**
     * @generated from protobuf field: map<int32, int32> dev_cards_purchased_turn = 13
     */
    devCardsPurchasedTurn: {
        [key: number]: number;
    }; // Map of DevCardType -> turn when purchased (hidden from other players)
}
/**
 * Port model for board trading bonuses
 *
 * @generated from protobuf message catan.v1.Port
 */
export interface Port {
    /**
     * Port location: edge (preferred) or vertex (for UI highlight)
     *
     * @generated from protobuf field: repeated string location = 1
     */
    location: string[]; // Vertex ID(s) or Edge ID for port
    /**
     * @generated from protobuf field: catan.v1.PortType type = 2
     */
    type: PortType;
    /**
     * @generated from protobuf field: catan.v1.Resource resource = 3
     */
    resource: Resource; // If specific, which resource (WOOD, BRICK, etc)
}
/**
 * The game board state
 *
 * @generated from protobuf message catan.v1.BoardState
 */
export interface BoardState {
    /**
     * @generated from protobuf field: repeated catan.v1.Hex hexes = 1
     */
    hexes: Hex[];
    /**
     * @generated from protobuf field: repeated catan.v1.Vertex vertices = 2
     */
    vertices: Vertex[];
    /**
     * @generated from protobuf field: repeated catan.v1.Edge edges = 3
     */
    edges: Edge[];
    /**
     * @generated from protobuf field: catan.v1.HexCoord robber_hex = 4
     */
    robberHex?: HexCoord;
    /**
     * @generated from protobuf field: repeated catan.v1.Port ports = 5
     */
    ports: Port[]; // Maritime trading ports
}
/**
 * Complete game state
 *
 * @generated from protobuf message catan.v1.GameState
 */
export interface GameState {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string code = 2
     */
    code: string; // 6-character join code
    /**
     * @generated from protobuf field: catan.v1.BoardState board = 3
     */
    board?: BoardState;
    /**
     * @generated from protobuf field: repeated catan.v1.PlayerState players = 4
     */
    players: PlayerState[];
    /**
     * @generated from protobuf field: int32 current_turn = 5
     */
    currentTurn: number; // Index of current player
    /**
     * @generated from protobuf field: catan.v1.TurnPhase turn_phase = 6
     */
    turnPhase: TurnPhase;
    /**
     * @generated from protobuf field: repeated int32 dice = 7
     */
    dice: number[]; // Always 2 values
    /**
     * @generated from protobuf field: catan.v1.GameStatus status = 8
     */
    status: GameStatus;
    /**
     * @generated from protobuf field: optional string longest_road_player_id = 9
     */
    longestRoadPlayerId?: string;
    /**
     * @generated from protobuf field: optional string largest_army_player_id = 10
     */
    largestArmyPlayerId?: string;
    /**
     * @generated from protobuf field: optional catan.v1.SetupPhase setup_phase = 11
     */
    setupPhase?: SetupPhase; // Present during setup status
    /**
     * @generated from protobuf field: optional catan.v1.RobberPhase robber_phase = 12
     */
    robberPhase?: RobberPhase; // Present during robber actions
    /**
     * @generated from protobuf field: repeated catan.v1.TradeOffer pending_trades = 13
     */
    pendingTrades: TradeOffer[];
    /**
     * @generated from protobuf field: repeated catan.v1.DevCardType dev_card_deck = 14
     */
    devCardDeck: DevCardType[]; // Remaining cards in deck (shuffled)
    /**
     * @generated from protobuf field: int32 turn_counter = 15
     */
    turnCounter: number; // Global turn counter (incremented each turn)
}
/**
 * Tracks the Robber phase state, including pending discards and steps.
 *
 * @generated from protobuf message catan.v1.RobberPhase
 */
export interface RobberPhase {
    /**
     * Player IDs still required to discard (if >7 cards when 7 is rolled).
     *
     * @generated from protobuf field: repeated string discard_pending = 1
     */
    discardPending: string[];
    /**
     * How many cards each player must discard.
     *
     * @generated from protobuf field: map<string, int32> discard_required = 2
     */
    discardRequired: {
        [key: string]: number;
    };
    /**
     * Player ID currently expected to move the robber (usually the roller).
     *
     * @generated from protobuf field: optional string move_pending_player_id = 3
     */
    movePendingPlayerId?: string;
    /**
     * Player ID currently expected to perform a steal (if any).
     *
     * @generated from protobuf field: optional string steal_pending_player_id = 4
     */
    stealPendingPlayerId?: string;
}
/**
 * A trade offer between players
 *
 * @generated from protobuf message catan.v1.TradeOffer
 */
export interface TradeOffer {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string proposer_id = 2
     */
    proposerId: string;
    /**
     * @generated from protobuf field: optional string target_id = 3
     */
    targetId?: string; // Empty = open to all
    /**
     * @generated from protobuf field: catan.v1.ResourceCount offering = 4
     */
    offering?: ResourceCount;
    /**
     * @generated from protobuf field: catan.v1.ResourceCount requesting = 5
     */
    requesting?: ResourceCount;
    /**
     * @generated from protobuf field: catan.v1.TradeStatus status = 6
     */
    status: TradeStatus;
}
/**
 * Setup phase tracking for initial placement
 *
 * @generated from protobuf message catan.v1.SetupPhase
 */
export interface SetupPhase {
    /**
     * @generated from protobuf field: int32 round = 1
     */
    round: number; // 1 or 2
    /**
     * @generated from protobuf field: int32 placements_in_turn = 2
     */
    placementsInTurn: number; // 0 = need settlement, 1 = need road
}
// ==================== REST API Types ====================

/**
 * @generated from protobuf message catan.v1.CreateGameRequest
 */
export interface CreateGameRequest {
    /**
     * @generated from protobuf field: string player_name = 1
     */
    playerName: string;
}
/**
 * @generated from protobuf message catan.v1.CreateGameResponse
 */
export interface CreateGameResponse {
    /**
     * @generated from protobuf field: string game_id = 1
     */
    gameId: string;
    /**
     * @generated from protobuf field: string code = 2
     */
    code: string;
    /**
     * @generated from protobuf field: string session_token = 3
     */
    sessionToken: string;
    /**
     * @generated from protobuf field: string player_id = 4
     */
    playerId: string;
}
/**
 * @generated from protobuf message catan.v1.JoinGameRequest
 */
export interface JoinGameRequest {
    /**
     * @generated from protobuf field: string player_name = 1
     */
    playerName: string;
}
/**
 * @generated from protobuf message catan.v1.JoinGameResponse
 */
export interface JoinGameResponse {
    /**
     * @generated from protobuf field: string game_id = 1
     */
    gameId: string;
    /**
     * @generated from protobuf field: string session_token = 2
     */
    sessionToken: string;
    /**
     * @generated from protobuf field: string player_id = 3
     */
    playerId: string;
    /**
     * @generated from protobuf field: repeated catan.v1.PlayerInfo players = 4
     */
    players: PlayerInfo[];
}
/**
 * @generated from protobuf message catan.v1.PlayerInfo
 */
export interface PlayerInfo {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: catan.v1.PlayerColor color = 3
     */
    color: PlayerColor;
}
/**
 * @generated from protobuf message catan.v1.GameInfoResponse
 */
export interface GameInfoResponse {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
    /**
     * @generated from protobuf field: catan.v1.GameStatus status = 2
     */
    status: GameStatus;
    /**
     * @generated from protobuf field: int32 player_count = 3
     */
    playerCount: number;
    /**
     * @generated from protobuf field: repeated catan.v1.PlayerInfo players = 4
     */
    players: PlayerInfo[];
}
// ==================== Enums ====================

/**
 * @generated from protobuf enum catan.v1.PortType
 */
export enum PortType {
    /**
     * @generated from protobuf enum value: PORT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PORT_TYPE_GENERIC = 1;
     */
    GENERIC = 1,
    /**
     * @generated from protobuf enum value: PORT_TYPE_SPECIFIC = 2;
     */
    SPECIFIC = 2
}
/**
 * @generated from protobuf enum catan.v1.Resource
 */
export enum Resource {
    /**
     * @generated from protobuf enum value: RESOURCE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: RESOURCE_WOOD = 1;
     */
    WOOD = 1,
    /**
     * @generated from protobuf enum value: RESOURCE_BRICK = 2;
     */
    BRICK = 2,
    /**
     * @generated from protobuf enum value: RESOURCE_SHEEP = 3;
     */
    SHEEP = 3,
    /**
     * @generated from protobuf enum value: RESOURCE_WHEAT = 4;
     */
    WHEAT = 4,
    /**
     * @generated from protobuf enum value: RESOURCE_ORE = 5;
     */
    ORE = 5
}
/**
 * @generated from protobuf enum catan.v1.TileResource
 */
export enum TileResource {
    /**
     * @generated from protobuf enum value: TILE_RESOURCE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TILE_RESOURCE_WOOD = 1;
     */
    WOOD = 1,
    /**
     * @generated from protobuf enum value: TILE_RESOURCE_BRICK = 2;
     */
    BRICK = 2,
    /**
     * @generated from protobuf enum value: TILE_RESOURCE_SHEEP = 3;
     */
    SHEEP = 3,
    /**
     * @generated from protobuf enum value: TILE_RESOURCE_WHEAT = 4;
     */
    WHEAT = 4,
    /**
     * @generated from protobuf enum value: TILE_RESOURCE_ORE = 5;
     */
    ORE = 5,
    /**
     * @generated from protobuf enum value: TILE_RESOURCE_DESERT = 6;
     */
    DESERT = 6
}
/**
 * @generated from protobuf enum catan.v1.BuildingType
 */
export enum BuildingType {
    /**
     * @generated from protobuf enum value: BUILDING_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: BUILDING_TYPE_SETTLEMENT = 1;
     */
    SETTLEMENT = 1,
    /**
     * @generated from protobuf enum value: BUILDING_TYPE_CITY = 2;
     */
    CITY = 2
}
/**
 * @generated from protobuf enum catan.v1.StructureType
 */
export enum StructureType {
    /**
     * @generated from protobuf enum value: STRUCTURE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STRUCTURE_TYPE_SETTLEMENT = 1;
     */
    SETTLEMENT = 1,
    /**
     * @generated from protobuf enum value: STRUCTURE_TYPE_CITY = 2;
     */
    CITY = 2,
    /**
     * @generated from protobuf enum value: STRUCTURE_TYPE_ROAD = 3;
     */
    ROAD = 3
}
/**
 * @generated from protobuf enum catan.v1.GameStatus
 */
export enum GameStatus {
    /**
     * @generated from protobuf enum value: GAME_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: GAME_STATUS_WAITING = 1;
     */
    WAITING = 1,
    /**
     * @generated from protobuf enum value: GAME_STATUS_SETUP = 2;
     */
    SETUP = 2,
    /**
     * @generated from protobuf enum value: GAME_STATUS_PLAYING = 3;
     */
    PLAYING = 3,
    /**
     * @generated from protobuf enum value: GAME_STATUS_FINISHED = 4;
     */
    FINISHED = 4
}
/**
 * @generated from protobuf enum catan.v1.TurnPhase
 */
export enum TurnPhase {
    /**
     * @generated from protobuf enum value: TURN_PHASE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TURN_PHASE_ROLL = 1;
     */
    ROLL = 1,
    /**
     * @generated from protobuf enum value: TURN_PHASE_TRADE = 2;
     */
    TRADE = 2,
    /**
     * @generated from protobuf enum value: TURN_PHASE_BUILD = 3;
     */
    BUILD = 3
}
/**
 * @generated from protobuf enum catan.v1.PlayerColor
 */
export enum PlayerColor {
    /**
     * @generated from protobuf enum value: PLAYER_COLOR_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PLAYER_COLOR_RED = 1;
     */
    RED = 1,
    /**
     * @generated from protobuf enum value: PLAYER_COLOR_BLUE = 2;
     */
    BLUE = 2,
    /**
     * @generated from protobuf enum value: PLAYER_COLOR_GREEN = 3;
     */
    GREEN = 3,
    /**
     * @generated from protobuf enum value: PLAYER_COLOR_ORANGE = 4;
     */
    ORANGE = 4
}
/**
 * @generated from protobuf enum catan.v1.DevCardType
 */
export enum DevCardType {
    /**
     * @generated from protobuf enum value: DEV_CARD_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DEV_CARD_TYPE_KNIGHT = 1;
     */
    KNIGHT = 1,
    /**
     * @generated from protobuf enum value: DEV_CARD_TYPE_ROAD_BUILDING = 2;
     */
    ROAD_BUILDING = 2,
    /**
     * @generated from protobuf enum value: DEV_CARD_TYPE_YEAR_OF_PLENTY = 3;
     */
    YEAR_OF_PLENTY = 3,
    /**
     * @generated from protobuf enum value: DEV_CARD_TYPE_MONOPOLY = 4;
     */
    MONOPOLY = 4,
    /**
     * @generated from protobuf enum value: DEV_CARD_TYPE_VICTORY_POINT = 5;
     */
    VICTORY_POINT = 5
}
/**
 * @generated from protobuf enum catan.v1.TradeStatus
 */
export enum TradeStatus {
    /**
     * @generated from protobuf enum value: TRADE_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_PENDING = 1;
     */
    PENDING = 1,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_ACCEPTED = 2;
     */
    ACCEPTED = 2,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_REJECTED = 3;
     */
    REJECTED = 3,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_CANCELLED = 4;
     */
    CANCELLED = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class HexCoord$Type extends MessageType<HexCoord> {
    constructor() {
        super("catan.v1.HexCoord", [
            { no: 1, name: "q", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "r", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HexCoord>): HexCoord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.q = 0;
        message.r = 0;
        if (value !== undefined)
            reflectionMergePartial<HexCoord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HexCoord): HexCoord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 q */ 1:
                    message.q = reader.int32();
                    break;
                case /* int32 r */ 2:
                    message.r = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HexCoord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 q = 1; */
        if (message.q !== 0)
            writer.tag(1, WireType.Varint).int32(message.q);
        /* int32 r = 2; */
        if (message.r !== 0)
            writer.tag(2, WireType.Varint).int32(message.r);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.HexCoord
 */
export const HexCoord = new HexCoord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Hex$Type extends MessageType<Hex> {
    constructor() {
        super("catan.v1.Hex", [
            { no: 1, name: "coord", kind: "message", T: () => HexCoord },
            { no: 2, name: "resource", kind: "enum", T: () => ["catan.v1.TileResource", TileResource, "TILE_RESOURCE_"] },
            { no: 3, name: "number", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Hex>): Hex {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resource = 0;
        message.number = 0;
        if (value !== undefined)
            reflectionMergePartial<Hex>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Hex): Hex {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catan.v1.HexCoord coord */ 1:
                    message.coord = HexCoord.internalBinaryRead(reader, reader.uint32(), options, message.coord);
                    break;
                case /* catan.v1.TileResource resource */ 2:
                    message.resource = reader.int32();
                    break;
                case /* int32 number */ 3:
                    message.number = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Hex, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catan.v1.HexCoord coord = 1; */
        if (message.coord)
            HexCoord.internalBinaryWrite(message.coord, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* catan.v1.TileResource resource = 2; */
        if (message.resource !== 0)
            writer.tag(2, WireType.Varint).int32(message.resource);
        /* int32 number = 3; */
        if (message.number !== 0)
            writer.tag(3, WireType.Varint).int32(message.number);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.Hex
 */
export const Hex = new Hex$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Building$Type extends MessageType<Building> {
    constructor() {
        super("catan.v1.Building", [
            { no: 1, name: "type", kind: "enum", T: () => ["catan.v1.BuildingType", BuildingType, "BUILDING_TYPE_"] },
            { no: 2, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Building>): Building {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.ownerId = "";
        if (value !== undefined)
            reflectionMergePartial<Building>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Building): Building {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catan.v1.BuildingType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Building, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catan.v1.BuildingType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string owner_id = 2; */
        if (message.ownerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.Building
 */
export const Building = new Building$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Road$Type extends MessageType<Road> {
    constructor() {
        super("catan.v1.Road", [
            { no: 1, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Road>): Road {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ownerId = "";
        if (value !== undefined)
            reflectionMergePartial<Road>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Road): Road {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner_id */ 1:
                    message.ownerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Road, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner_id = 1; */
        if (message.ownerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ownerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.Road
 */
export const Road = new Road$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vertex$Type extends MessageType<Vertex> {
    constructor() {
        super("catan.v1.Vertex", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "adjacent_hexes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HexCoord },
            { no: 3, name: "building", kind: "message", T: () => Building }
        ]);
    }
    create(value?: PartialMessage<Vertex>): Vertex {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.adjacentHexes = [];
        if (value !== undefined)
            reflectionMergePartial<Vertex>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vertex): Vertex {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated catan.v1.HexCoord adjacent_hexes */ 2:
                    message.adjacentHexes.push(HexCoord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional catan.v1.Building building */ 3:
                    message.building = Building.internalBinaryRead(reader, reader.uint32(), options, message.building);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vertex, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated catan.v1.HexCoord adjacent_hexes = 2; */
        for (let i = 0; i < message.adjacentHexes.length; i++)
            HexCoord.internalBinaryWrite(message.adjacentHexes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional catan.v1.Building building = 3; */
        if (message.building)
            Building.internalBinaryWrite(message.building, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.Vertex
 */
export const Vertex = new Vertex$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Edge$Type extends MessageType<Edge> {
    constructor() {
        super("catan.v1.Edge", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "vertices", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "road", kind: "message", T: () => Road }
        ]);
    }
    create(value?: PartialMessage<Edge>): Edge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.vertices = [];
        if (value !== undefined)
            reflectionMergePartial<Edge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Edge): Edge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated string vertices */ 2:
                    message.vertices.push(reader.string());
                    break;
                case /* optional catan.v1.Road road */ 3:
                    message.road = Road.internalBinaryRead(reader, reader.uint32(), options, message.road);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Edge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated string vertices = 2; */
        for (let i = 0; i < message.vertices.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.vertices[i]);
        /* optional catan.v1.Road road = 3; */
        if (message.road)
            Road.internalBinaryWrite(message.road, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.Edge
 */
export const Edge = new Edge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceCount$Type extends MessageType<ResourceCount> {
    constructor() {
        super("catan.v1.ResourceCount", [
            { no: 1, name: "wood", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "brick", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sheep", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "wheat", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "ore", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResourceCount>): ResourceCount {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.wood = 0;
        message.brick = 0;
        message.sheep = 0;
        message.wheat = 0;
        message.ore = 0;
        if (value !== undefined)
            reflectionMergePartial<ResourceCount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceCount): ResourceCount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 wood */ 1:
                    message.wood = reader.int32();
                    break;
                case /* int32 brick */ 2:
                    message.brick = reader.int32();
                    break;
                case /* int32 sheep */ 3:
                    message.sheep = reader.int32();
                    break;
                case /* int32 wheat */ 4:
                    message.wheat = reader.int32();
                    break;
                case /* int32 ore */ 5:
                    message.ore = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceCount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 wood = 1; */
        if (message.wood !== 0)
            writer.tag(1, WireType.Varint).int32(message.wood);
        /* int32 brick = 2; */
        if (message.brick !== 0)
            writer.tag(2, WireType.Varint).int32(message.brick);
        /* int32 sheep = 3; */
        if (message.sheep !== 0)
            writer.tag(3, WireType.Varint).int32(message.sheep);
        /* int32 wheat = 4; */
        if (message.wheat !== 0)
            writer.tag(4, WireType.Varint).int32(message.wheat);
        /* int32 ore = 5; */
        if (message.ore !== 0)
            writer.tag(5, WireType.Varint).int32(message.ore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.ResourceCount
 */
export const ResourceCount = new ResourceCount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerState$Type extends MessageType<PlayerState> {
    constructor() {
        super("catan.v1.PlayerState", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "color", kind: "enum", T: () => ["catan.v1.PlayerColor", PlayerColor, "PLAYER_COLOR_"] },
            { no: 4, name: "resources", kind: "message", T: () => ResourceCount },
            { no: 5, name: "dev_card_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "knights_played", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "victory_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "is_ready", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "is_host", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "victory_point_cards", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "dev_cards", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 13, name: "dev_cards_purchased_turn", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<PlayerState>): PlayerState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.color = 0;
        message.devCardCount = 0;
        message.knightsPlayed = 0;
        message.victoryPoints = 0;
        message.connected = false;
        message.isReady = false;
        message.isHost = false;
        message.victoryPointCards = 0;
        message.devCards = {};
        message.devCardsPurchasedTurn = {};
        if (value !== undefined)
            reflectionMergePartial<PlayerState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerState): PlayerState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* catan.v1.PlayerColor color */ 3:
                    message.color = reader.int32();
                    break;
                case /* catan.v1.ResourceCount resources */ 4:
                    message.resources = ResourceCount.internalBinaryRead(reader, reader.uint32(), options, message.resources);
                    break;
                case /* int32 dev_card_count */ 5:
                    message.devCardCount = reader.int32();
                    break;
                case /* int32 knights_played */ 6:
                    message.knightsPlayed = reader.int32();
                    break;
                case /* int32 victory_points */ 7:
                    message.victoryPoints = reader.int32();
                    break;
                case /* bool connected */ 8:
                    message.connected = reader.bool();
                    break;
                case /* bool is_ready */ 9:
                    message.isReady = reader.bool();
                    break;
                case /* bool is_host */ 10:
                    message.isHost = reader.bool();
                    break;
                case /* int32 victory_point_cards */ 11:
                    message.victoryPointCards = reader.int32();
                    break;
                case /* map<int32, int32> dev_cards */ 12:
                    this.binaryReadMap12(message.devCards, reader, options);
                    break;
                case /* map<int32, int32> dev_cards_purchased_turn */ 13:
                    this.binaryReadMap13(message.devCardsPurchasedTurn, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    // @ts-ignore - Generated code has unused parameters
    private binaryReadMap12(map: PlayerState["devCards"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PlayerState["devCards"] | undefined, val: PlayerState["devCards"][any] | undefined;
        while (reader.pos < end) {
            // @ts-ignore - Generated code has unused parameters
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for catan.v1.PlayerState.dev_cards");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    // @ts-ignore - Generated code has unused parameters
    private binaryReadMap13(map: PlayerState["devCardsPurchasedTurn"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PlayerState["devCardsPurchasedTurn"] | undefined, val: PlayerState["devCardsPurchasedTurn"][any] | undefined;
        while (reader.pos < end) {
            // @ts-ignore - Generated code has unused parameters
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for catan.v1.PlayerState.dev_cards_purchased_turn");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: PlayerState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* catan.v1.PlayerColor color = 3; */
        if (message.color !== 0)
            writer.tag(3, WireType.Varint).int32(message.color);
        /* catan.v1.ResourceCount resources = 4; */
        if (message.resources)
            ResourceCount.internalBinaryWrite(message.resources, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 dev_card_count = 5; */
        if (message.devCardCount !== 0)
            writer.tag(5, WireType.Varint).int32(message.devCardCount);
        /* int32 knights_played = 6; */
        if (message.knightsPlayed !== 0)
            writer.tag(6, WireType.Varint).int32(message.knightsPlayed);
        /* int32 victory_points = 7; */
        if (message.victoryPoints !== 0)
            writer.tag(7, WireType.Varint).int32(message.victoryPoints);
        /* bool connected = 8; */
        if (message.connected !== false)
            writer.tag(8, WireType.Varint).bool(message.connected);
        /* bool is_ready = 9; */
        if (message.isReady !== false)
            writer.tag(9, WireType.Varint).bool(message.isReady);
        /* bool is_host = 10; */
        if (message.isHost !== false)
            writer.tag(10, WireType.Varint).bool(message.isHost);
        /* int32 victory_point_cards = 11; */
        if (message.victoryPointCards !== 0)
            writer.tag(11, WireType.Varint).int32(message.victoryPointCards);
        /* map<int32, int32> dev_cards = 12; */
        for (let k of globalThis.Object.keys(message.devCards))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.devCards[k as any]).join();
        /* map<int32, int32> dev_cards_purchased_turn = 13; */
        for (let k of globalThis.Object.keys(message.devCardsPurchasedTurn))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.devCardsPurchasedTurn[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.PlayerState
 */
export const PlayerState = new PlayerState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Port$Type extends MessageType<Port> {
    constructor() {
        super("catan.v1.Port", [
            { no: 1, name: "location", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["catan.v1.PortType", PortType, "PORT_TYPE_"] },
            { no: 3, name: "resource", kind: "enum", T: () => ["catan.v1.Resource", Resource, "RESOURCE_"] }
        ]);
    }
    create(value?: PartialMessage<Port>): Port {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.location = [];
        message.type = 0;
        message.resource = 0;
        if (value !== undefined)
            reflectionMergePartial<Port>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Port): Port {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string location */ 1:
                    message.location.push(reader.string());
                    break;
                case /* catan.v1.PortType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* catan.v1.Resource resource */ 3:
                    message.resource = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Port, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string location = 1; */
        for (let i = 0; i < message.location.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.location[i]);
        /* catan.v1.PortType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* catan.v1.Resource resource = 3; */
        if (message.resource !== 0)
            writer.tag(3, WireType.Varint).int32(message.resource);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.Port
 */
export const Port = new Port$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoardState$Type extends MessageType<BoardState> {
    constructor() {
        super("catan.v1.BoardState", [
            { no: 1, name: "hexes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Hex },
            { no: 2, name: "vertices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Vertex },
            { no: 3, name: "edges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Edge },
            { no: 4, name: "robber_hex", kind: "message", T: () => HexCoord },
            { no: 5, name: "ports", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Port }
        ]);
    }
    create(value?: PartialMessage<BoardState>): BoardState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hexes = [];
        message.vertices = [];
        message.edges = [];
        message.ports = [];
        if (value !== undefined)
            reflectionMergePartial<BoardState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoardState): BoardState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catan.v1.Hex hexes */ 1:
                    message.hexes.push(Hex.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated catan.v1.Vertex vertices */ 2:
                    message.vertices.push(Vertex.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated catan.v1.Edge edges */ 3:
                    message.edges.push(Edge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* catan.v1.HexCoord robber_hex */ 4:
                    message.robberHex = HexCoord.internalBinaryRead(reader, reader.uint32(), options, message.robberHex);
                    break;
                case /* repeated catan.v1.Port ports */ 5:
                    message.ports.push(Port.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoardState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catan.v1.Hex hexes = 1; */
        for (let i = 0; i < message.hexes.length; i++)
            Hex.internalBinaryWrite(message.hexes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated catan.v1.Vertex vertices = 2; */
        for (let i = 0; i < message.vertices.length; i++)
            Vertex.internalBinaryWrite(message.vertices[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated catan.v1.Edge edges = 3; */
        for (let i = 0; i < message.edges.length; i++)
            Edge.internalBinaryWrite(message.edges[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* catan.v1.HexCoord robber_hex = 4; */
        if (message.robberHex)
            HexCoord.internalBinaryWrite(message.robberHex, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated catan.v1.Port ports = 5; */
        for (let i = 0; i < message.ports.length; i++)
            Port.internalBinaryWrite(message.ports[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.BoardState
 */
export const BoardState = new BoardState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameState$Type extends MessageType<GameState> {
    constructor() {
        super("catan.v1.GameState", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "board", kind: "message", T: () => BoardState },
            { no: 4, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PlayerState },
            { no: 5, name: "current_turn", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "turn_phase", kind: "enum", T: () => ["catan.v1.TurnPhase", TurnPhase, "TURN_PHASE_"] },
            { no: 7, name: "dice", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "status", kind: "enum", T: () => ["catan.v1.GameStatus", GameStatus, "GAME_STATUS_"] },
            { no: 9, name: "longest_road_player_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "largest_army_player_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "setup_phase", kind: "message", T: () => SetupPhase },
            { no: 12, name: "robber_phase", kind: "message", T: () => RobberPhase },
            { no: 13, name: "pending_trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradeOffer },
            { no: 14, name: "dev_card_deck", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["catan.v1.DevCardType", DevCardType, "DEV_CARD_TYPE_"] },
            { no: 15, name: "turn_counter", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GameState>): GameState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.code = "";
        message.players = [];
        message.currentTurn = 0;
        message.turnPhase = 0;
        message.dice = [];
        message.status = 0;
        message.pendingTrades = [];
        message.devCardDeck = [];
        message.turnCounter = 0;
        if (value !== undefined)
            reflectionMergePartial<GameState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameState): GameState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* catan.v1.BoardState board */ 3:
                    message.board = BoardState.internalBinaryRead(reader, reader.uint32(), options, message.board);
                    break;
                case /* repeated catan.v1.PlayerState players */ 4:
                    message.players.push(PlayerState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 current_turn */ 5:
                    message.currentTurn = reader.int32();
                    break;
                case /* catan.v1.TurnPhase turn_phase */ 6:
                    message.turnPhase = reader.int32();
                    break;
                case /* repeated int32 dice */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dice.push(reader.int32());
                    else
                        message.dice.push(reader.int32());
                    break;
                case /* catan.v1.GameStatus status */ 8:
                    message.status = reader.int32();
                    break;
                case /* optional string longest_road_player_id */ 9:
                    message.longestRoadPlayerId = reader.string();
                    break;
                case /* optional string largest_army_player_id */ 10:
                    message.largestArmyPlayerId = reader.string();
                    break;
                case /* optional catan.v1.SetupPhase setup_phase */ 11:
                    message.setupPhase = SetupPhase.internalBinaryRead(reader, reader.uint32(), options, message.setupPhase);
                    break;
                case /* optional catan.v1.RobberPhase robber_phase */ 12:
                    message.robberPhase = RobberPhase.internalBinaryRead(reader, reader.uint32(), options, message.robberPhase);
                    break;
                case /* repeated catan.v1.TradeOffer pending_trades */ 13:
                    message.pendingTrades.push(TradeOffer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated catan.v1.DevCardType dev_card_deck */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.devCardDeck.push(reader.int32());
                    else
                        message.devCardDeck.push(reader.int32());
                    break;
                case /* int32 turn_counter */ 15:
                    message.turnCounter = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* catan.v1.BoardState board = 3; */
        if (message.board)
            BoardState.internalBinaryWrite(message.board, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated catan.v1.PlayerState players = 4; */
        for (let i = 0; i < message.players.length; i++)
            PlayerState.internalBinaryWrite(message.players[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 current_turn = 5; */
        if (message.currentTurn !== 0)
            writer.tag(5, WireType.Varint).int32(message.currentTurn);
        /* catan.v1.TurnPhase turn_phase = 6; */
        if (message.turnPhase !== 0)
            writer.tag(6, WireType.Varint).int32(message.turnPhase);
        /* repeated int32 dice = 7; */
        if (message.dice.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.dice.length; i++)
                writer.int32(message.dice[i]);
            writer.join();
        }
        /* catan.v1.GameStatus status = 8; */
        if (message.status !== 0)
            writer.tag(8, WireType.Varint).int32(message.status);
        /* optional string longest_road_player_id = 9; */
        if (message.longestRoadPlayerId !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.longestRoadPlayerId);
        /* optional string largest_army_player_id = 10; */
        if (message.largestArmyPlayerId !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.largestArmyPlayerId);
        /* optional catan.v1.SetupPhase setup_phase = 11; */
        if (message.setupPhase)
            SetupPhase.internalBinaryWrite(message.setupPhase, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional catan.v1.RobberPhase robber_phase = 12; */
        if (message.robberPhase)
            RobberPhase.internalBinaryWrite(message.robberPhase, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated catan.v1.TradeOffer pending_trades = 13; */
        for (let i = 0; i < message.pendingTrades.length; i++)
            TradeOffer.internalBinaryWrite(message.pendingTrades[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated catan.v1.DevCardType dev_card_deck = 14; */
        if (message.devCardDeck.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.devCardDeck.length; i++)
                writer.int32(message.devCardDeck[i]);
            writer.join();
        }
        /* int32 turn_counter = 15; */
        if (message.turnCounter !== 0)
            writer.tag(15, WireType.Varint).int32(message.turnCounter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.GameState
 */
export const GameState = new GameState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RobberPhase$Type extends MessageType<RobberPhase> {
    constructor() {
        super("catan.v1.RobberPhase", [
            { no: 1, name: "discard_pending", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "discard_required", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 3, name: "move_pending_player_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "steal_pending_player_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RobberPhase>): RobberPhase {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.discardPending = [];
        message.discardRequired = {};
        if (value !== undefined)
            reflectionMergePartial<RobberPhase>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RobberPhase): RobberPhase {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string discard_pending */ 1:
                    message.discardPending.push(reader.string());
                    break;
                case /* map<string, int32> discard_required */ 2:
                    this.binaryReadMap2(message.discardRequired, reader, options);
                    break;
                case /* optional string move_pending_player_id */ 3:
                    message.movePendingPlayerId = reader.string();
                    break;
                case /* optional string steal_pending_player_id */ 4:
                    message.stealPendingPlayerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    // @ts-ignore - Generated code has unused parameters
    private binaryReadMap2(map: RobberPhase["discardRequired"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RobberPhase["discardRequired"] | undefined, val: RobberPhase["discardRequired"][any] | undefined;
        while (reader.pos < end) {
            // @ts-ignore - Generated code has unused parameters
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for catan.v1.RobberPhase.discard_required");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: RobberPhase, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string discard_pending = 1; */
        for (let i = 0; i < message.discardPending.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.discardPending[i]);
        /* map<string, int32> discard_required = 2; */
        for (let k of globalThis.Object.keys(message.discardRequired))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.discardRequired[k]).join();
        /* optional string move_pending_player_id = 3; */
        if (message.movePendingPlayerId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.movePendingPlayerId);
        /* optional string steal_pending_player_id = 4; */
        if (message.stealPendingPlayerId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.stealPendingPlayerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.RobberPhase
 */
export const RobberPhase = new RobberPhase$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeOffer$Type extends MessageType<TradeOffer> {
    constructor() {
        super("catan.v1.TradeOffer", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "offering", kind: "message", T: () => ResourceCount },
            { no: 5, name: "requesting", kind: "message", T: () => ResourceCount },
            { no: 6, name: "status", kind: "enum", T: () => ["catan.v1.TradeStatus", TradeStatus, "TRADE_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<TradeOffer>): TradeOffer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.proposerId = "";
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<TradeOffer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeOffer): TradeOffer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string proposer_id */ 2:
                    message.proposerId = reader.string();
                    break;
                case /* optional string target_id */ 3:
                    message.targetId = reader.string();
                    break;
                case /* catan.v1.ResourceCount offering */ 4:
                    message.offering = ResourceCount.internalBinaryRead(reader, reader.uint32(), options, message.offering);
                    break;
                case /* catan.v1.ResourceCount requesting */ 5:
                    message.requesting = ResourceCount.internalBinaryRead(reader, reader.uint32(), options, message.requesting);
                    break;
                case /* catan.v1.TradeStatus status */ 6:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeOffer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string proposer_id = 2; */
        if (message.proposerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.proposerId);
        /* optional string target_id = 3; */
        if (message.targetId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.targetId);
        /* catan.v1.ResourceCount offering = 4; */
        if (message.offering)
            ResourceCount.internalBinaryWrite(message.offering, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* catan.v1.ResourceCount requesting = 5; */
        if (message.requesting)
            ResourceCount.internalBinaryWrite(message.requesting, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* catan.v1.TradeStatus status = 6; */
        if (message.status !== 0)
            writer.tag(6, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.TradeOffer
 */
export const TradeOffer = new TradeOffer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetupPhase$Type extends MessageType<SetupPhase> {
    constructor() {
        super("catan.v1.SetupPhase", [
            { no: 1, name: "round", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "placements_in_turn", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetupPhase>): SetupPhase {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.round = 0;
        message.placementsInTurn = 0;
        if (value !== undefined)
            reflectionMergePartial<SetupPhase>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetupPhase): SetupPhase {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 round */ 1:
                    message.round = reader.int32();
                    break;
                case /* int32 placements_in_turn */ 2:
                    message.placementsInTurn = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetupPhase, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 round = 1; */
        if (message.round !== 0)
            writer.tag(1, WireType.Varint).int32(message.round);
        /* int32 placements_in_turn = 2; */
        if (message.placementsInTurn !== 0)
            writer.tag(2, WireType.Varint).int32(message.placementsInTurn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.SetupPhase
 */
export const SetupPhase = new SetupPhase$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateGameRequest$Type extends MessageType<CreateGameRequest> {
    constructor() {
        super("catan.v1.CreateGameRequest", [
            { no: 1, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateGameRequest>): CreateGameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerName = "";
        if (value !== undefined)
            reflectionMergePartial<CreateGameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateGameRequest): CreateGameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_name */ 1:
                    message.playerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateGameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_name = 1; */
        if (message.playerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.CreateGameRequest
 */
export const CreateGameRequest = new CreateGameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateGameResponse$Type extends MessageType<CreateGameResponse> {
    constructor() {
        super("catan.v1.CreateGameResponse", [
            { no: 1, name: "game_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "session_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateGameResponse>): CreateGameResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gameId = "";
        message.code = "";
        message.sessionToken = "";
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateGameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateGameResponse): CreateGameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string game_id */ 1:
                    message.gameId = reader.string();
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* string session_token */ 3:
                    message.sessionToken = reader.string();
                    break;
                case /* string player_id */ 4:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateGameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string game_id = 1; */
        if (message.gameId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gameId);
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* string session_token = 3; */
        if (message.sessionToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sessionToken);
        /* string player_id = 4; */
        if (message.playerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.CreateGameResponse
 */
export const CreateGameResponse = new CreateGameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinGameRequest$Type extends MessageType<JoinGameRequest> {
    constructor() {
        super("catan.v1.JoinGameRequest", [
            { no: 1, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JoinGameRequest>): JoinGameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerName = "";
        if (value !== undefined)
            reflectionMergePartial<JoinGameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinGameRequest): JoinGameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_name */ 1:
                    message.playerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinGameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_name = 1; */
        if (message.playerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.JoinGameRequest
 */
export const JoinGameRequest = new JoinGameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinGameResponse$Type extends MessageType<JoinGameResponse> {
    constructor() {
        super("catan.v1.JoinGameResponse", [
            { no: 1, name: "game_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "session_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PlayerInfo }
        ]);
    }
    create(value?: PartialMessage<JoinGameResponse>): JoinGameResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gameId = "";
        message.sessionToken = "";
        message.playerId = "";
        message.players = [];
        if (value !== undefined)
            reflectionMergePartial<JoinGameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinGameResponse): JoinGameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string game_id */ 1:
                    message.gameId = reader.string();
                    break;
                case /* string session_token */ 2:
                    message.sessionToken = reader.string();
                    break;
                case /* string player_id */ 3:
                    message.playerId = reader.string();
                    break;
                case /* repeated catan.v1.PlayerInfo players */ 4:
                    message.players.push(PlayerInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinGameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string game_id = 1; */
        if (message.gameId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gameId);
        /* string session_token = 2; */
        if (message.sessionToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionToken);
        /* string player_id = 3; */
        if (message.playerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.playerId);
        /* repeated catan.v1.PlayerInfo players = 4; */
        for (let i = 0; i < message.players.length; i++)
            PlayerInfo.internalBinaryWrite(message.players[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.JoinGameResponse
 */
export const JoinGameResponse = new JoinGameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerInfo$Type extends MessageType<PlayerInfo> {
    constructor() {
        super("catan.v1.PlayerInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "color", kind: "enum", T: () => ["catan.v1.PlayerColor", PlayerColor, "PLAYER_COLOR_"] }
        ]);
    }
    create(value?: PartialMessage<PlayerInfo>): PlayerInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.color = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerInfo): PlayerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* catan.v1.PlayerColor color */ 3:
                    message.color = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* catan.v1.PlayerColor color = 3; */
        if (message.color !== 0)
            writer.tag(3, WireType.Varint).int32(message.color);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.PlayerInfo
 */
export const PlayerInfo = new PlayerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameInfoResponse$Type extends MessageType<GameInfoResponse> {
    constructor() {
        super("catan.v1.GameInfoResponse", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["catan.v1.GameStatus", GameStatus, "GAME_STATUS_"] },
            { no: 3, name: "player_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PlayerInfo }
        ]);
    }
    create(value?: PartialMessage<GameInfoResponse>): GameInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.status = 0;
        message.playerCount = 0;
        message.players = [];
        if (value !== undefined)
            reflectionMergePartial<GameInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameInfoResponse): GameInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* catan.v1.GameStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* int32 player_count */ 3:
                    message.playerCount = reader.int32();
                    break;
                case /* repeated catan.v1.PlayerInfo players */ 4:
                    message.players.push(PlayerInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* catan.v1.GameStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* int32 player_count = 3; */
        if (message.playerCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.playerCount);
        /* repeated catan.v1.PlayerInfo players = 4; */
        for (let i = 0; i < message.players.length; i++)
            PlayerInfo.internalBinaryWrite(message.players[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catan.v1.GameInfoResponse
 */
export const GameInfoResponse = new GameInfoResponse$Type();
